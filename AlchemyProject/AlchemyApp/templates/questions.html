{% extends "public.html" %}
{% load get_item from template_filters %}

{% block body %}

<!-- Makes the div as tall as the screen, and centers elements horizontally and vertically. Also makes it so that if there is too much content, a scroll bar appears -->
<div class="flex h-screen overflow-auto bg-gray-100">

    <div class="flex flex-col h-screen hidden md:block p-4 text-center border-r bg-white">
        <ul class="h-full flex flex-col justify-between">
            {% for family in control_families %}
            <li>
                <a href="{% url 'alchemy:questions' family.family_name %}" class="text-blue-600 hover:bg-blue-700 hover:text-white block rounded-lg px-4 {% if family.family_name == current_family_name %}bg-blue-700 text-white{% endif %}">
                    <span class="font-bold text-lg">{{ family.family_name }}</span>
                </a>
            </li>
            {% endfor %}
        </ul>
    </div>

    <div id="question_answer_wrapper" class="flex flex-grow items-center justify-center"> 
        <!-- The main section has responsive width -->
        <div class="mx-12 w-full min-w-512 lg:w-256 bg-white p-10 rounded-lg shadow-lg">

            <!-- Div for questions navigation section. Relative attribute so that the line that is behind the number buttons is in the middle -->
            <div id="questions-navigation" class="relative mt-5 mb-10">

                <!-- Line that is behind the number buttons -->
                <div class="absolute top-1/2 left-0 right-0 h-0.5 bg-blue-500 opacity-40"></div>

                <!-- The question buttons for navigation -->
                <ul class="flex justify-between px-4">
                    {% for question in questions %}
                        <li>
                            <button data-index="{{forloop.counter0}}" class="relative z-10 question-nav-btn nav-btn-{{ forloop.counter0 }} bg-blue-500 text-white font-bold text-xl py-1 px-3 rounded focus:outline-none focus:shadow-outline">
                                {{ forloop.counter }}
                            </button>
                        </li>
                    {% endfor %}
                </ul>
            </div>

            <!-- Div sections for each question. Only one is visible at a time so it is a smoother user experience (i.e. one html file but seems like multiple pages) -->
            {% for question in questions %}
                <div class="question-wrapper hidden mb-5">

                    <!-- Section for control information. Lists all the controls the question is viable for -->
                    <div class="question-controls">
                        <ul class="list-none">
                            {% for control in question.controls.all %}
                                <li class="font-bold text-lg text-blue-700 mb-1">{{ control.control_family.family_abbreviation }}-{{ control.control_number }}{% if control.control_enhancement %} ({{ control.control_enhancement }}){% endif %}: <span class="text-blue-400">{{control.control_name}}</span></li>
                            {% endfor %}
                        </ul>
                    </div>

                    <!-- Section for the control text -->
                    <div id="question-content" data-question={{question.id}} class="question-text mt-2">
                        <p>{{question.question_text}}</p>
                    </div>

                    <!-- Section for the textarea for the answer -->
                    <div class="mt-5">
                        <label for="question-answer" class="block mb-2 text-sm font-medium opacity-70">Your Answer</label>
                        <textarea rows="4" class="question-answer block p-2.5 w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 focus:ring-blue-500 focus:border-blue-500" data-answer="{{ client_answers|get_item:question.id|default:'' }}" placeholder="Write your answer here..."></textarea>    
                    </div>
                </div>
            {% endfor %}

            <!-- Section at the bottom with the previous, next, and save buttons -->
            <div class="flex justify-between mt-10">
                <button id="previous-button" class="w-36 bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-2 px-4 mr-2 rounded focus:outline-none focus:shadow-outline disabled:opacity-50 disabled:cursor-not-allowed inline-block">Previous</button>
                <button id="save-button" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-2 px-4 rounded focus:outline-none focus:shadow-outline inline-block">Save</button>
                <button id="next-button"class="w-36 bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-2 px-4 ml-2 rounded focus:outline-none focus:shadow-outline disabled:opacity-50 disabled:cursor-not-allowed inline-block">Next</button>
            </div>
        </div>
    </div>
</div>

<script type="text/javascript">

    const questionWrappers = document.querySelectorAll('.question-wrapper');
    const previousButton = document.querySelector('#previous-button');
    const nextButton = document.querySelector('#next-button');
    let currentQuestionIndex = 0;

    // Load the last active question index from sessionStorage or default to 0
    const lastActiveQuestionIndex = parseInt(sessionStorage.getItem('lastActiveQuestionIndex')) || 0;
    currentQuestionIndex = lastActiveQuestionIndex;

    // Show the last active question or the first question by default
    changeVisibility(questionWrappers[currentQuestionIndex], true);

    // If user hits the left or right arrow keys, go to the previous or next question after saving the current answer, respectively
    document.addEventListener("keydown", (event) => {

        if (event.key === "ArrowLeft" && currentQuestionIndex !== 0) {
            saveCurrentAnswer(currentQuestionIndex); // Save the current answer before navigating

            changeVisibility(questionWrappers[currentQuestionIndex], false);
            currentQuestionIndex--;
            saveCurrentQuestionIndex(currentQuestionIndex);
            changeVisibility(questionWrappers[currentQuestionIndex], true);
            updateNavButtons();

        } 
        
        else if (event.key === "ArrowRight" && currentQuestionIndex < (questionWrappers.length - 1)) {
            saveCurrentAnswer(currentQuestionIndex); // Save the current answer before navigating

            changeVisibility(questionWrappers[currentQuestionIndex], false);
            currentQuestionIndex++;
            saveCurrentQuestionIndex(currentQuestionIndex);
            changeVisibility(questionWrappers[currentQuestionIndex], true);
            updateNavButtons();
        }

        else if (event.key === 'Tab') {
            
            event.preventDefault(); // Prevent the default tab behavior
            questionWrappers[currentQuestionIndex].querySelector('.question-answer').focus();
        }
    });

    // If the user clicks the next button, go to the previous or next question after saving the current answer, respectively
    nextButton.addEventListener("click", () => {

        if (currentQuestionIndex < (questionWrappers.length-1)) { // If we're not on the first question, then the previous button is active

            saveCurrentAnswer(currentQuestionIndex); // Save the current answer before navigating

            changeVisibility(questionWrappers[currentQuestionIndex], false);  // Hide the current question
            currentQuestionIndex++; // Increment the index and show the next question
            saveCurrentQuestionIndex(currentQuestionIndex);
            changeVisibility(questionWrappers[currentQuestionIndex], true);

            updateNavButtons(); // Change how the nav buttons look
        }
    });

    // If the user clicks the previous button, go to the previous or next question after saving the current answer, respectively
    previousButton.addEventListener("click", () => {

        if (currentQuestionIndex != 0) { // If we're not on the first question, then the previous button is active

            saveCurrentAnswer(currentQuestionIndex); // Save the current answer before navigating

            changeVisibility(questionWrappers[currentQuestionIndex], false); // Hide the current question
            currentQuestionIndex--; // Decrement the index and show the previous question
            saveCurrentQuestionIndex(currentQuestionIndex);
            changeVisibility(questionWrappers[currentQuestionIndex], true);

            updateNavButtons(); // Change how the nav buttons look
        }
    });

    // When the save buttons is clicked, route the textarea information into an API call by sending a POST request to a route in urls.py
    document.querySelector("#save-button").addEventListener("click", () => {
        saveCurrentAnswer(currentQuestionIndex);
    })

    // When the user navigates to a new page, switches tabs, closes the tab, minimizes or closes the browser, save the text content of the answer shown using the /answer API call
    window.addEventListener('beforeunload', () => {
        saveCurrentAnswer(currentQuestionIndex);
    });

    // When the user refreshes the page, save the text content of the answer shown using the /answer API call
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
            saveCurrentAnswer(currentQuestionIndex);
        }
    });

    // Add a new event listener for question navigation buttons
    document.querySelectorAll(".question-nav-btn").forEach((btn) => {
        btn.addEventListener("click", (event) => {

            saveCurrentAnswer(currentQuestionIndex);
            
            const newIndex = parseInt(event.target.dataset.index);

            // Hide the current question
            changeVisibility(questionWrappers[currentQuestionIndex], false);

            // Set the new index and show the new question
            currentQuestionIndex = newIndex;
            saveCurrentQuestionIndex(currentQuestionIndex);

            changeVisibility(questionWrappers[currentQuestionIndex], true);

            // Update navigation buttons
            updateNavButtons();
        });
    });

    // Update the navigation buttons on page load
    updateNavButtons();

    // Function that stores the current question index into the session storage as a key/value pair. This is so that when a user refreshes the page, they see the question/answer content that they were last on
    function saveCurrentQuestionIndex(index) {
    sessionStorage.setItem('lastActiveQuestionIndex', index);
    }

    // Function that updates how the nav buttons look with the different sizing. Called whenever a navigational element (arrow keys, next/previous buttons, nav bar button) is clicked
    function updateNavButtons() {
        const navButtons = document.querySelectorAll(".question-nav-btn");

        navButtons.forEach((btn, index) => {
            if (index === currentQuestionIndex) {
            btn.style.transform = 'scale(1.4)';
            btn.style.fontSize = '24px';
            btn.classList.add("bg-blue-600");
            btn.classList.remove("bg-blue-500");
            } else {
            btn.style.transform = 'scale(.9)';
            btn.style.fontSize = '16px';
            btn.classList.remove("bg-blue-600");
            btn.classList.add("bg-blue-500");
            }
        });

        // Disable or enable the Previous button based on the current question index
        previousButton.disabled = currentQuestionIndex === 0;

        // Change the Next button text to "Review" when on the last question
        if (currentQuestionIndex === (questionWrappers.length - 1)) {
            nextButton.textContent = "Review";
            nextButton.classList.add("bg-orange-500", "hover:bg-orange-700");
            nextButton.classList.remove("bg-blue-500", "hover:bg-blue-700");
        } 
        
        else {
            nextButton.textContent = "Next";
            nextButton.classList.add("bg-blue-500", "hover:bg-blue-700");
            nextButton.classList.remove("bg-orange-500", "hover:bg-orange-700");
        }

        // Disable or enable the Next button based on all text boxes being filled
        nextButton.disabled = (!checkAllTextboxesFilled() && (currentQuestionIndex === (questionWrappers.length - 1)))
        
        }
    
    // Function to check if all text boxes have content in them
    function checkAllTextboxesFilled() {
        const textareas = document.querySelectorAll(".question-answer");
        for (const textarea of textareas) {
            if (textarea.value.trim() === "") {
                return false;
            }
        }
        return true;
    }

    function saveCurrentAnswer(currentQuestionIndex) {

        // get the text value of the textarea being shown
        const answerField = questionWrappers[currentQuestionIndex].querySelector('.question-answer');
        const answer = answerField.value.trim();

        // get the question id of the question being shown
        const questionContent = questionWrappers[currentQuestionIndex].querySelector("#question-content");
        const questionId = questionContent.dataset.question;

        //perform an API call to asynchronously pass the answer data to the answer url (and then answer view) where it will be saved to the database and linked to the question
        fetch('/answer', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                answer: answer,
                question: questionId
            })
        })

        // Receive response from server side to know if post was successfully added to database or not
        .then(response => response.json())
        .then(result => {
            console.log(result);

            // Update the data-answer attribute
            answerField.dataset.answer = answer;

        });

        // Call checkAllTextboxesFilled() after saving the current answer
        if (currentQuestionIndex == (questionWrappers.length - 1)) {
            nextButton.disabled = !checkAllTextboxesFilled();
        }

    }

    async function populateSavedAnswers() {

        const answerPromises = Array.from(document.querySelectorAll('.question-answer')).map(async (answerField) => {
            const questionId = answerField.closest(".question-wrapper").querySelector("#question-content").dataset.question;
            
            const response = await fetch(`/get_answer?question_id=${questionId}`);
            const result = await response.json();

            if (result && result.answer) {
                answerField.value = result.answer;
                answerField.dataset.answer = result.answer;
            }
        });

    await Promise.all(answerPromises);

    // Update nav button colors after populating saved answers
    const textareas = document.querySelectorAll(".question-answer");
    textareas.forEach((textarea, index) => {
        updateNavButtonColor(index, textarea.value.trim().length > 0);
    });

    }

    function updateNavButtonColor(questionIndex, hasAnswer) {

        const questionNavButtons = document.querySelectorAll(".question-nav-btn");

        if (hasAnswer) {
            questionNavButtons[questionIndex].classList.add("bg-orange-500", "hover:bg-orange-700");
            questionNavButtons[questionIndex].classList.remove("bg-blue-500", "hover:bg-blue-700");
        } else {
            questionNavButtons[questionIndex].classList.add("bg-blue-500", "hover:bg-blue-700");
            questionNavButtons[questionIndex].classList.remove("bg-orange-500", "hover:bg-orange-700");
        }
    }

    function changeVisibility(element, isVisible) {
        if (isVisible) {
            element.classList.remove("hidden");
        } else {
            element.classList.add("hidden");
        }
    }

    document.addEventListener("DOMContentLoaded", async () => {
        await populateSavedAnswers();
    });

    document.querySelectorAll(".question-answer").forEach((textarea, index) => {
        textarea.addEventListener("input", () => {
             // Disable or enable the Next button based on all text boxes being filled
        nextButton.disabled = (!checkAllTextboxesFilled() && (currentQuestionIndex === (questionWrappers.length - 1)))

            // Update the navigation button color based on whether the textarea has content
            updateNavButtonColor(index, textarea.value.trim().length > 0);
        });
    });

</script>

{% endblock %}